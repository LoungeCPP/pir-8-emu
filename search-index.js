var N=null,E="",T="t",U="u",searchIndex={};
var R=["partialord","num_traits","numcast","option","min_value","max_value","infinity","neg_infinity","neg_zero","Returns `-0.0`.","Returns the smallest finite value that this type can…","min_positive_value","Returns the smallest positive, normalized value that this…","Returns epsilon, a small positive value.","Returns the largest finite value that this type can…","is_infinite","is_finite","is_normal","Returns `true` if the number is neither zero, infinite,…","classify","Returns the floating point category of the number. If only…","fpcategory","Returns the largest integer less than or equal to a number.","Returns the smallest integer greater than or equal to a…","Returns the nearest integer to a number. Round half-way…","Return the integer part of a number.","Returns the fractional part of a number.","Computes the absolute value of `self`. Returns…","Returns a number that represents the sign of `self`.","is_sign_positive","is_sign_negative","Raise a number to an integer power.","to_degrees","to_radians","Returns the maximum of the two numbers.","Returns the minimum of the two numbers.","integer_decode","Returns the mantissa, base 2 exponent, and sign as…","Shifts the bits to the left by a specified amount amount,…","Shifts the bits to the right by a specified amount amount,…","num_traits::ops","Fused multiply-add. Computes `(self * a) + b` with only…","mul_add","Performs the fused multiply-add operation.","checkedmul","The result after applying the operator.","epsilon","Returns `true` if `self` is positive, including `+0.0`,…","Returns `true` if `self` is negative, including `-0.0`,…","Take the reciprocal (inverse) of a number, `1/x`.","Take the square root of a number.","Returns `e^(self)`, (the exponential function).","Returns `2^(self)`.","Returns the natural logarithm of the number.","Returns the logarithm of the number with respect to an…","Returns the base 2 logarithm of the number.","Returns the base 10 logarithm of the number.","Converts radians to degrees.","Converts degrees to radians.","The positive difference of two numbers.","Take the cubic root of a number.","Calculate the length of the hypotenuse of a right-angle…","Computes the sine of a number (in radians).","Computes the cosine of a number (in radians).","Computes the tangent of a number (in radians).","Computes the arcsine of a number. Return value is in…","Computes the arccosine of a number. Return value is in…","Computes the arctangent of a number. Return value is in…","Computes the four quadrant arctangent of `self` (`y`) and…","Simultaneously computes the sine and cosine of the number,…","Returns `e^(self) - 1` in a way that is accurate even if…","Returns `ln(1+n)` (natural logarithm) more accurately than…","Hyperbolic sine function.","Hyperbolic cosine function.","Hyperbolic tangent function.","Inverse hyperbolic sine function.","Inverse hyperbolic cosine function.","Inverse hyperbolic tangent function.","abs_sub","signed","Computes the absolute value.","signum","Returns the sign of the number.","try_from","try_into","result","borrow_mut","formatter","ParseFloatError","FloatErrorKind","ToPrimitive","FromPrimitive","AsPrimitive","FloatCore","FloatConst","CheckedAdd","CheckedSub","CheckedMul","CheckedDiv","CheckedRem","CheckedNeg","CheckedShl","CheckedShr","MulAddAssign","Saturating","WrappingAdd","WrappingSub","WrappingMul","WrappingShl","WrappingShr","generalpurposeregister","Create a new, empty register named as specified.","pir_8_emu::isa::instruction","pir_8_emu::isa::instruction::Instruction","pir_8_emu","to_string","pir_8_emu::isa","clone_into","to_owned","type_id","specialpurposeregister","instruction","displayinstruction","ordering","instructionstckdirection","instructionstckregisterpair","aluoperation","aluoperationshiftorrotatedirection","aluoperationshiftorrotatetype","partial_cmp","deref_mut","GeneralPurposeRegister","SpecialPurposeRegister","AluOperationShiftOrRotateDirection","AluOperationShiftOrRotateType","InstructionStckRegisterPair","InstructionStckDirection","AluOperation","Instruction","DisplayInstruction"];
searchIndex["num_traits"]={"doc":"Numeric traits for generic mathematics","i":[[3,R[88],R[1],E,N,N],[12,"kind",E,E,0,N],[4,R[89],E,E,N,N],[13,"Empty",E,E,1,N],[13,"Invalid",E,E,1,N],[5,"clamp",E,"A value bounded by a minimum and a maximum",N,[[[R[0]]],[R[0]]]],[0,"bounds",E,E,N,N],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",N,N],[10,R[4],E,"returns the smallest finite number this type can represent",2,[[],["self"]]],[10,R[5],E,"returns the largest finite number this type can represent",2,[[],["self"]]],[0,"cast",R[1],E,N,N],[5,"cast","num_traits::cast","Cast from one machine scalar to another.",N,[[[R[2]]],[[R[2]],[R[3]]]]],[8,R[90],E,"A generic trait for converting a value to a number.",N,N],[11,"to_isize",E,"Converts the value of `self` to an `isize`.",3,[[["self"]],[["isize"],[R[3],["isize"]]]]],[11,"to_i8",E,"Converts the value of `self` to an `i8`.",3,[[["self"]],[[R[3],["i8"]],["i8"]]]],[11,"to_i16",E,"Converts the value of `self` to an `i16`.",3,[[["self"]],[[R[3],["i16"]],["i16"]]]],[11,"to_i32",E,"Converts the value of `self` to an `i32`.",3,[[["self"]],[["i32"],[R[3],["i32"]]]]],[10,"to_i64",E,"Converts the value of `self` to an `i64`.",3,[[["self"]],[[R[3],["i64"]],["i64"]]]],[11,"to_i128",E,"Converts the value of `self` to an `i128`.",3,[[["self"]],[[R[3],["i128"]],["i128"]]]],[11,"to_usize",E,"Converts the value of `self` to a `usize`.",3,[[["self"]],[[R[3],["usize"]],["usize"]]]],[11,"to_u8",E,"Converts the value of `self` to an `u8`.",3,[[["self"]],[[R[3],["u8"]],["u8"]]]],[11,"to_u16",E,"Converts the value of `self` to an `u16`.",3,[[["self"]],[["u16"],[R[3],["u16"]]]]],[11,"to_u32",E,"Converts the value of `self` to an `u32`.",3,[[["self"]],[[R[3],["u32"]],["u32"]]]],[10,"to_u64",E,"Converts the value of `self` to an `u64`.",3,[[["self"]],[[R[3],["u64"]],["u64"]]]],[11,"to_u128",E,"Converts the value of `self` to an `u128`.",3,[[["self"]],[["u128"],[R[3],["u128"]]]]],[11,"to_f32",E,"Converts the value of `self` to an `f32`.",3,[[["self"]],[["f32"],[R[3],["f32"]]]]],[11,"to_f64",E,"Converts the value of `self` to an `f64`.",3,[[["self"]],[[R[3],["f64"]],["f64"]]]],[8,R[91],E,"A generic trait for converting a number to a value.",N,N],[11,"from_isize",E,"Convert an `isize` to return an optional value of this…",4,[[["isize"]],[R[3]]]],[11,"from_i8",E,"Convert an `i8` to return an optional value of this type.…",4,[[["i8"]],[R[3]]]],[11,"from_i16",E,"Convert an `i16` to return an optional value of this type.…",4,[[["i16"]],[R[3]]]],[11,"from_i32",E,"Convert an `i32` to return an optional value of this type.…",4,[[["i32"]],[R[3]]]],[10,"from_i64",E,"Convert an `i64` to return an optional value of this type.…",4,[[["i64"]],[R[3]]]],[11,"from_i128",E,"Convert an `i128` to return an optional value of this…",4,[[["i128"]],[R[3]]]],[11,"from_usize",E,"Convert a `usize` to return an optional value of this…",4,[[["usize"]],[R[3]]]],[11,"from_u8",E,"Convert an `u8` to return an optional value of this type.…",4,[[["u8"]],[R[3]]]],[11,"from_u16",E,"Convert an `u16` to return an optional value of this type.…",4,[[["u16"]],[R[3]]]],[11,"from_u32",E,"Convert an `u32` to return an optional value of this type.…",4,[[["u32"]],[R[3]]]],[10,"from_u64",E,"Convert an `u64` to return an optional value of this type.…",4,[[["u64"]],[R[3]]]],[11,"from_u128",E,"Convert an `u128` to return an optional value of this…",4,[[["u128"]],[R[3]]]],[11,"from_f32",E,"Convert a `f32` to return an optional value of this type.…",4,[[["f32"]],[R[3]]]],[11,"from_f64",E,"Convert a `f64` to return an optional value of this type.…",4,[[["f64"]],[R[3]]]],[8,"NumCast",E,"An interface for casting between machine scalars.",N,N],[10,"from",E,"Creates a number from another value that can be converted…",5,[[["toprimitive"]],[R[3]]]],[8,R[92],E,"A generic interface for casting between machine scalars…",N,N],[10,"as_",E,"Convert a value to another, using the `as` operator.",6,[[],[T]]],[0,"float",R[1],E,N,N],[8,R[93],"num_traits::float","Generic trait for floating point numbers that works with…",N,N],[10,R[6],E,"Returns positive infinity.",7,[[],["self"]]],[10,R[7],E,"Returns negative infinity.",7,[[],["self"]]],[10,"nan",E,"Returns NaN.",7,[[],["self"]]],[10,R[8],E,R[9],7,[[],["self"]]],[10,R[4],E,R[10],7,[[],["self"]]],[10,R[11],E,R[12],7,[[],["self"]]],[10,R[46],E,R[13],7,[[],["self"]]],[10,R[5],E,R[14],7,[[],["self"]]],[11,"is_nan",E,"Returns `true` if the number is NaN.",7,[[],["bool"]]],[11,R[15],E,"Returns `true` if the number is infinite.",7,[[],["bool"]]],[11,R[16],E,"Returns `true` if the number is neither infinite or NaN.",7,[[],["bool"]]],[11,R[17],E,R[18],7,[[],["bool"]]],[10,R[19],E,R[20],7,[[],[R[21]]]],[11,"floor",E,R[22],7,[[],["self"]]],[11,"ceil",E,R[23],7,[[],["self"]]],[11,"round",E,R[24],7,[[],["self"]]],[11,"trunc",E,R[25],7,[[],["self"]]],[11,"fract",E,R[26],7,[[],["self"]]],[11,"abs",E,R[27],7,[[],["self"]]],[11,R[81],E,R[28],7,[[],["self"]]],[11,R[29],E,"Returns `true` if `self` is positive, including `+0.0` and…",7,[[],["bool"]]],[11,R[30],E,"Returns `true` if `self` is negative, including `-0.0` and…",7,[[],["bool"]]],[11,"min",E,R[35],7,[[],["self"]]],[11,"max",E,R[34],7,[[],["self"]]],[11,"recip",E,"Returns the reciprocal (multiplicative inverse) of the…",7,[[],["self"]]],[11,"powi",E,R[31],7,[[["i32"]],["self"]]],[10,R[32],E,"Converts to degrees, assuming the number is in radians.",7,[[],["self"]]],[10,R[33],E,"Converts to radians, assuming the number is in degrees.",7,[[],["self"]]],[10,R[36],E,R[37],7,[[]]],[8,"Float",E,"Generic trait for floating point numbers",N,N],[10,"nan",E,"Returns the `NaN` value.",8,[[],["self"]]],[10,R[6],E,"Returns the infinite value.",8,[[],["self"]]],[10,R[7],E,"Returns the negative infinite value.",8,[[],["self"]]],[10,R[8],E,R[9],8,[[],["self"]]],[10,R[4],E,R[10],8,[[],["self"]]],[10,R[11],E,R[12],8,[[],["self"]]],[11,R[46],E,R[13],8,[[],["self"]]],[10,R[5],E,R[14],8,[[],["self"]]],[10,"is_nan",E,"Returns `true` if this value is `NaN` and false otherwise.",8,[[],["bool"]]],[10,R[15],E,"Returns `true` if this value is positive infinity or…",8,[[],["bool"]]],[10,R[16],E,"Returns `true` if this number is neither infinite nor `NaN`.",8,[[],["bool"]]],[10,R[17],E,R[18],8,[[],["bool"]]],[10,R[19],E,R[20],8,[[],[R[21]]]],[10,"floor",E,R[22],8,[[],["self"]]],[10,"ceil",E,R[23],8,[[],["self"]]],[10,"round",E,R[24],8,[[],["self"]]],[10,"trunc",E,R[25],8,[[],["self"]]],[10,"fract",E,R[26],8,[[],["self"]]],[10,"abs",E,R[27],8,[[],["self"]]],[10,R[81],E,R[28],8,[[],["self"]]],[10,R[29],E,R[47],8,[[],["bool"]]],[10,R[30],E,R[48],8,[[],["bool"]]],[10,R[42],E,R[41],8,[[],["self"]]],[10,"recip",E,R[49],8,[[],["self"]]],[10,"powi",E,R[31],8,[[["i32"]],["self"]]],[10,"powf",E,"Raise a number to a floating point power.",8,[[],["self"]]],[10,"sqrt",E,R[50],8,[[],["self"]]],[10,"exp",E,R[51],8,[[],["self"]]],[10,"exp2",E,R[52],8,[[],["self"]]],[10,"ln",E,R[53],8,[[],["self"]]],[10,"log",E,R[54],8,[[],["self"]]],[10,"log2",E,R[55],8,[[],["self"]]],[10,"log10",E,R[56],8,[[],["self"]]],[11,R[32],E,R[57],8,[[],["self"]]],[11,R[33],E,R[58],8,[[],["self"]]],[10,"max",E,R[34],8,[[],["self"]]],[10,"min",E,R[35],8,[[],["self"]]],[10,R[78],E,R[59],8,[[],["self"]]],[10,"cbrt",E,R[60],8,[[],["self"]]],[10,"hypot",E,R[61],8,[[],["self"]]],[10,"sin",E,R[62],8,[[],["self"]]],[10,"cos",E,R[63],8,[[],["self"]]],[10,"tan",E,R[64],8,[[],["self"]]],[10,"asin",E,R[65],8,[[],["self"]]],[10,"acos",E,R[66],8,[[],["self"]]],[10,"atan",E,R[67],8,[[],["self"]]],[10,"atan2",E,R[68],8,[[],["self"]]],[10,"sin_cos",E,R[69],8,[[]]],[10,"exp_m1",E,R[70],8,[[],["self"]]],[10,"ln_1p",E,R[71],8,[[],["self"]]],[10,"sinh",E,R[72],8,[[],["self"]]],[10,"cosh",E,R[73],8,[[],["self"]]],[10,"tanh",E,R[74],8,[[],["self"]]],[10,"asinh",E,R[75],8,[[],["self"]]],[10,"acosh",E,R[76],8,[[],["self"]]],[10,"atanh",E,R[77],8,[[],["self"]]],[10,R[36],E,R[37],8,[[]]],[8,R[94],E,E,N,N],[10,"E",E,"Return Euler’s number.",9,[[],["self"]]],[10,"FRAC_1_PI",E,"Return `1.0 / π`.",9,[[],["self"]]],[10,"FRAC_1_SQRT_2",E,"Return `1.0 / sqrt(2.0)`.",9,[[],["self"]]],[10,"FRAC_2_PI",E,"Return `2.0 / π`.",9,[[],["self"]]],[10,"FRAC_2_SQRT_PI",E,"Return `2.0 / sqrt(π)`.",9,[[],["self"]]],[10,"FRAC_PI_2",E,"Return `π / 2.0`.",9,[[],["self"]]],[10,"FRAC_PI_3",E,"Return `π / 3.0`.",9,[[],["self"]]],[10,"FRAC_PI_4",E,"Return `π / 4.0`.",9,[[],["self"]]],[10,"FRAC_PI_6",E,"Return `π / 6.0`.",9,[[],["self"]]],[10,"FRAC_PI_8",E,"Return `π / 8.0`.",9,[[],["self"]]],[10,"LN_10",E,"Return `ln(10.0)`.",9,[[],["self"]]],[10,"LN_2",E,"Return `ln(2.0)`.",9,[[],["self"]]],[10,"LOG10_E",E,"Return `log10(e)`.",9,[[],["self"]]],[10,"LOG2_E",E,"Return `log2(e)`.",9,[[],["self"]]],[10,"PI",E,"Return Archimedes’ constant.",9,[[],["self"]]],[10,"SQRT_2",E,"Return `sqrt(2.0)`.",9,[[],["self"]]],[0,"identities",R[1],E,N,N],[5,"zero","num_traits::identities","Returns the additive identity, `0`.",N,[[],["zero"]]],[5,"one",E,"Returns the multiplicative identity, `1`.",N,[[],["one"]]],[8,"Zero",E,"Defines an additive identity element for `Self`.",N,N],[10,"zero",E,"Returns the additive identity element of `Self`, `0`. #…",10,[[],["self"]]],[11,"set_zero",E,"Sets `self` to the additive identity element of `Self`, `0`.",10,[[["self"]]]],[10,"is_zero",E,"Returns `true` if `self` is equal to the additive identity.",10,[[["self"]],["bool"]]],[8,"One",E,"Defines a multiplicative identity element for `Self`.",N,N],[10,"one",E,"Returns the multiplicative identity element of `Self`, `1`.",11,[[],["self"]]],[11,"set_one",E,"Sets `self` to the multiplicative identity element of…",11,[[["self"]]]],[11,"is_one",E,"Returns `true` if `self` is equal to the multiplicative…",11,[[["self"]],["bool"]]],[0,"int",R[1],E,N,N],[8,"PrimInt","num_traits::int","Generic trait for primitive integers.",N,N],[10,"count_ones",E,"Returns the number of ones in the binary representation of…",12,[[],["u32"]]],[10,"count_zeros",E,"Returns the number of zeros in the binary representation…",12,[[],["u32"]]],[10,"leading_zeros",E,"Returns the number of leading zeros in the binary…",12,[[],["u32"]]],[10,"trailing_zeros",E,"Returns the number of trailing zeros in the binary…",12,[[],["u32"]]],[10,"rotate_left",E,R[38],12,[[["u32"]],["self"]]],[10,"rotate_right",E,R[39],12,[[["u32"]],["self"]]],[10,"signed_shl",E,R[38],12,[[["u32"]],["self"]]],[10,"signed_shr",E,R[39],12,[[["u32"]],["self"]]],[10,"unsigned_shl",E,R[38],12,[[["u32"]],["self"]]],[10,"unsigned_shr",E,R[39],12,[[["u32"]],["self"]]],[10,"swap_bytes",E,"Reverses the byte order of the integer.",12,[[],["self"]]],[10,"from_be",E,"Convert an integer from big endian to the target's…",12,[[],["self"]]],[10,"from_le",E,"Convert an integer from little endian to the target's…",12,[[],["self"]]],[10,"to_be",E,"Convert `self` to big endian from the target's endianness.",12,[[],["self"]]],[10,"to_le",E,"Convert `self` to little endian from the target's…",12,[[],["self"]]],[10,"pow",E,"Raises self to the power of `exp`, using exponentiation by…",12,[[["u32"]],["self"]]],[0,"ops",R[1],E,N,N],[0,"checked",R[40],E,N,N],[8,R[95],"num_traits::ops::checked","Performs addition that returns `None` instead of wrapping…",N,N],[10,"checked_add",E,"Adds two numbers, checking for overflow. If overflow…",13,[[["self"]],[R[3]]]],[8,R[96],E,"Performs subtraction that returns `None` instead of…",N,N],[10,"checked_sub",E,"Subtracts two numbers, checking for underflow. If…",14,[[["self"]],[R[3]]]],[8,R[97],E,"Performs multiplication that returns `None` instead of…",N,N],[10,"checked_mul",E,"Multiplies two numbers, checking for underflow or…",15,[[["self"]],[R[3]]]],[8,R[98],E,"Performs division that returns `None` instead of panicking…",N,N],[10,"checked_div",E,"Divides two numbers, checking for underflow, overflow and…",16,[[["self"]],[R[3]]]],[8,R[99],E,"Performs an integral remainder that returns `None` instead…",N,N],[10,"checked_rem",E,"Finds the remainder of dividing two numbers, checking for…",17,[[["self"]],[R[3]]]],[8,R[100],E,"Performs negation that returns `None` if the result can't…",N,N],[10,"checked_neg",E,"Negates a number, returning `None` for results that can't…",18,[[["self"]],[R[3]]]],[8,R[101],E,"Performs a left shift that returns `None` on shifts larger…",N,N],[10,"checked_shl",E,"Checked shift left. Computes `self << rhs`, returning…",19,[[["self"],["u32"]],[R[3]]]],[8,R[102],E,"Performs a right shift that returns `None` on shifts…",N,N],[10,"checked_shr",E,"Checked shift right. Computes `self >> rhs`, returning…",20,[[["self"],["u32"]],[R[3]]]],[0,"inv",R[40],E,N,N],[8,"Inv","num_traits::ops::inv","Unary operator for retrieving the multiplicative inverse,…",N,N],[16,"Output",E,R[45],21,N],[10,"inv",E,"Returns the multiplicative inverse of `self`.",21,[[]]],[0,R[42],R[40],E,N,N],[8,"MulAdd","num_traits::ops::mul_add",R[41],N,N],[16,"Output",E,"The resulting type after applying the fused multiply-add.",22,N],[10,R[42],E,R[43],22,[[["a"],["b"]]]],[8,R[103],E,"The fused multiply-add assignment operation.",N,N],[10,"mul_add_assign",E,R[43],23,[[["self"],["a"],["b"]]]],[0,"saturating",R[40],E,N,N],[8,R[104],"num_traits::ops::saturating","Saturating math operations",N,N],[10,"saturating_add",E,"Saturating addition operator. Returns a+b, saturating at…",24,[[],["self"]]],[10,"saturating_sub",E,"Saturating subtraction operator. Returns a-b, saturating…",24,[[],["self"]]],[0,"wrapping",R[40],E,N,N],[8,R[105],"num_traits::ops::wrapping","Performs addition that wraps around on overflow.",N,N],[10,"wrapping_add",E,"Wrapping (modular) addition. Computes `self + other`,…",25,[[["self"]],["self"]]],[8,R[106],E,"Performs subtraction that wraps around on overflow.",N,N],[10,"wrapping_sub",E,"Wrapping (modular) subtraction. Computes `self - other`,…",26,[[["self"]],["self"]]],[8,R[107],E,"Performs multiplication that wraps around on overflow.",N,N],[10,"wrapping_mul",E,"Wrapping (modular) multiplication. Computes `self *…",27,[[["self"]],["self"]]],[8,R[108],E,"Performs a left shift that does not panic.",N,N],[10,"wrapping_shl",E,"Panic-free bitwise shift-left; yields `self << mask(rhs)`,…",28,[[["self"],["u32"]],["self"]]],[8,R[109],E,"Performs a right shift that does not panic.",N,N],[10,"wrapping_shr",E,"Panic-free bitwise shift-right; yields `self >>…",29,[[["self"],["u32"]],["self"]]],[0,"pow",R[1],E,N,N],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation…",N,[[["usize"],["mul"],["one"],["clone"]],[["mul"],["one"],["clone"]]]],[5,"checked_pow",E,"Raises a value to the power of exp, returning `None` if an…",N,[[[R[44]],["usize"],["one"],["clone"]],[[R[3]],[R[44]],["one"],["clone"]]]],[8,"Pow",E,"Binary operator for raising a value to a power.",N,N],[16,"Output",E,R[45],30,N],[10,"pow",E,"Returns `self` to the power `rhs`.",30,[[["rhs"]]]],[0,"real",R[1],E,N,N],[8,"Real","num_traits::real","A trait for real number types that do not necessarily have…",N,N],[10,R[4],E,R[10],31,[[],["self"]]],[10,R[11],E,R[12],31,[[],["self"]]],[10,R[46],E,R[13],31,[[],["self"]]],[10,R[5],E,R[14],31,[[],["self"]]],[10,"floor",E,R[22],31,[[],["self"]]],[10,"ceil",E,R[23],31,[[],["self"]]],[10,"round",E,R[24],31,[[],["self"]]],[10,"trunc",E,R[25],31,[[],["self"]]],[10,"fract",E,R[26],31,[[],["self"]]],[10,"abs",E,R[27],31,[[],["self"]]],[10,R[81],E,R[28],31,[[],["self"]]],[10,R[29],E,R[47],31,[[],["bool"]]],[10,R[30],E,R[48],31,[[],["bool"]]],[10,R[42],E,R[41],31,[[],["self"]]],[10,"recip",E,R[49],31,[[],["self"]]],[10,"powi",E,R[31],31,[[["i32"]],["self"]]],[10,"powf",E,"Raise a number to a real number power.",31,[[],["self"]]],[10,"sqrt",E,R[50],31,[[],["self"]]],[10,"exp",E,R[51],31,[[],["self"]]],[10,"exp2",E,R[52],31,[[],["self"]]],[10,"ln",E,R[53],31,[[],["self"]]],[10,"log",E,R[54],31,[[],["self"]]],[10,"log2",E,R[55],31,[[],["self"]]],[10,"log10",E,R[56],31,[[],["self"]]],[10,R[32],E,R[57],31,[[],["self"]]],[10,R[33],E,R[58],31,[[],["self"]]],[10,"max",E,R[34],31,[[],["self"]]],[10,"min",E,R[35],31,[[],["self"]]],[10,R[78],E,R[59],31,[[],["self"]]],[10,"cbrt",E,R[60],31,[[],["self"]]],[10,"hypot",E,R[61],31,[[],["self"]]],[10,"sin",E,R[62],31,[[],["self"]]],[10,"cos",E,R[63],31,[[],["self"]]],[10,"tan",E,R[64],31,[[],["self"]]],[10,"asin",E,R[65],31,[[],["self"]]],[10,"acos",E,R[66],31,[[],["self"]]],[10,"atan",E,R[67],31,[[],["self"]]],[10,"atan2",E,R[68],31,[[],["self"]]],[10,"sin_cos",E,R[69],31,[[]]],[10,"exp_m1",E,R[70],31,[[],["self"]]],[10,"ln_1p",E,R[71],31,[[],["self"]]],[10,"sinh",E,R[72],31,[[],["self"]]],[10,"cosh",E,R[73],31,[[],["self"]]],[10,"tanh",E,R[74],31,[[],["self"]]],[10,"asinh",E,R[75],31,[[],["self"]]],[10,"acosh",E,R[76],31,[[],["self"]]],[10,"atanh",E,R[77],31,[[],["self"]]],[0,"sign",R[1],E,N,N],[5,"abs","num_traits::sign",R[80],N,[[[R[79]]],[R[79]]]],[5,R[78],E,R[59],N,[[[R[79]]],[R[79]]]],[5,R[81],E,R[82],N,[[[R[79]]],[R[79]]]],[8,"Signed",E,"Useful functions for signed numbers (i.e. numbers that can…",N,N],[10,"abs",E,R[80],32,[[["self"]],["self"]]],[10,R[78],E,R[59],32,[[["self"]],["self"]]],[10,R[81],E,R[82],32,[[["self"]],["self"]]],[10,"is_positive",E,"Returns true if the number is positive and false if the…",32,[[["self"]],["bool"]]],[10,"is_negative",E,"Returns true if the number is negative and false if the…",32,[[["self"]],["bool"]]],[8,"Unsigned",E,"A trait for values which cannot be negative",N,N],[8,"Num",R[1],"The base trait for numeric types, covering `0` and `1`…",N,N],[16,"FromStrRadixErr",E,E,33,N],[10,"from_str_radix",E,"Convert from a string and radix <= 36.",33,[[["u32"],["str"]],[R[85]]]],[8,"NumOps",E,"The trait for types implementing basic numeric operations",N,N],[8,"NumRef",E,"The trait for `Num` types which also implement numeric…",N,N],[8,"RefNum",E,"The trait for references which implement numeric…",N,N],[8,"NumAssignOps",E,"The trait for types implementing numeric assignment…",N,N],[8,"NumAssign",E,"The trait for `Num` types which also implement assignment…",N,N],[8,"NumAssignRef",E,"The trait for `NumAssign` types which also implement…",N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[83],E,E,0,[[[U]],[R[85]]]],[11,"into",E,E,0,[[],[U]]],[11,R[84],E,E,0,[[],[R[85]]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,R[86],E,E,0,[[["self"]],[T]]],[11,R[119],E,E,0,[[["self"]],["typeid"]]],[11,R[115],E,E,0,[[["self"]],["string"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[83],E,E,1,[[[U]],[R[85]]]],[11,"into",E,E,1,[[],[U]]],[11,R[84],E,E,1,[[],[R[85]]]],[11,"borrow",E,E,1,[[["self"]],[T]]],[11,R[86],E,E,1,[[["self"]],[T]]],[11,R[119],E,E,1,[[["self"]],["typeid"]]],[11,"fmt",E,E,1,[[[R[87]],["self"]],[R[85]]]],[11,"fmt",E,E,0,[[[R[87]],["self"]],[R[85]]]],[11,"fmt",E,E,0,[[["self"],[R[87]]],[R[85]]]]],"p":[[3,R[88]],[4,R[89]],[8,"Bounded"],[8,R[90]],[8,R[91]],[8,"NumCast"],[8,R[92]],[8,R[93]],[8,"Float"],[8,R[94]],[8,"Zero"],[8,"One"],[8,"PrimInt"],[8,R[95]],[8,R[96]],[8,R[97]],[8,R[98]],[8,R[99]],[8,R[100]],[8,R[101]],[8,R[102]],[8,"Inv"],[8,"MulAdd"],[8,R[103]],[8,R[104]],[8,R[105]],[8,R[106]],[8,R[107]],[8,R[108]],[8,R[109]],[8,"Pow"],[8,"Real"],[8,"Signed"],[8,"Num"]]};
searchIndex["pir_8_emu"]={"doc":E,"i":[[3,"Cpu",R[114],E,N,N],[11,"new",E,E,0,[[],["cpu"]]],[0,"isa",E,E,N,N],[3,R[131],R[116],"There are eight 8-bit General Purpose registers, each has…",N,N],[3,R[132],E,"There are some special purpose registers that you cannot…",N,N],[5,"default_general_purpose_registers",E,"Get the default 8 GP registers specified in the ISA",N,[[]]],[11,"new",E,R[111],1,[[["char"],["u8"]],[[R[3],[R[110]]],[R[110]]]]],[11,"address",E,"The address for this register",1,[[["self"]],["u8"]]],[11,"letter",E,"The letter/mnemonic for this register",1,[[["self"]],["char"]]],[11,"new",E,R[111],2,[[["str"]],[R[120]]]],[11,"name",E,"The full name of this register",2,[[["self"]],["str"]]],[11,"short_name",E,"The short/mnemonical name of this register",2,[[["self"]],["str"]]],[0,R[121],E,E,N,N],[3,R[139],R[112],"Helper struct for assembly-printing instructions with…",N,N],[4,R[133],E,"If D is a `1`, the shift is to the left, all bits will…",N,N],[13,"Left",E,E,3,N],[13,"Right",E,E,3,N],[4,R[134],E,"All shifts can be performed left or right, as designated…",N,N],[13,"Lsf",E,"Logical shift - a zero is inserted",4,N],[13,"Asf",E,"Arithmetic shift - a zero is inserted for left shift,…",4,N],[13,"Rtc",E,"Rotate with carry - the Carry flag is inserted (Carry flag…",4,N],[13,"Rtw",E,"Rotate without carry - the bit shifted out is is inserted",4,N],[4,R[135],E,"The R bit indicates the register pair; 0 for A & B and 1…",N,N],[13,"Ab",E,E,5,N],[13,"Cd",E,E,5,N],[4,R[136],E,"The D bit indicates the direction; 0 for PUSH and 1 for POP.",N,N],[13,"Push",E,E,6,N],[13,"Pop",E,E,6,N],[4,R[137],E,"Any CPU instruction of the pattern `0011 FFFF` will invoke…",N,N],[13,"Reserved",E,"Reserved operation, contains the entire nibble",7,N],[13,"Add",E,"Addition of register X and register Y",7,N],[13,"Sub",E,"Subtraction of register Y from register X (X-Y)",7,N],[13,"Not",E,"Bitwise NOT",7,N],[13,"Or",E,"Bitwise OR",7,N],[13,"Xor",E,"Bitwise XOR",7,N],[13,"And",E,"Bitwise AND",7,N],[13,"ShiftOrRotate",E,"Shift or Rotate, see member doc",7,N],[12,"d","pir_8_emu::isa::instruction::AluOperation",E,7,N],[12,"tt",E,E,7,N],[4,R[138],R[112],"Instructions will increase the PC by one, unless otherwise…",N,N],[13,"Reserved",E,"Reserved instruction, contains the entire byte",8,N],[13,"Jump",E,"Jump, see section above",8,N],[12,"xxx",R[113],E,8,N],[13,"LoadImmediate",R[112],"Load the the next byte into register `AAA` (PC will be…",8,N],[12,"aaa",R[113],E,8,N],[13,"LoadIndirect",R[112],"Load value in address indicated by the next two bytes into…",8,N],[12,"aaa",R[113],E,8,N],[13,"Save",R[112],"Store value in register `AAA` in address indicated by the…",8,N],[12,"aaa",R[113],E,8,N],[13,"Alu",R[112],"ALU based operations, see member doc",8,N],[13,"Move",E,"Move a value from register `AAA` to register `BBB`",8,N],[12,"aaa",R[113],E,8,N],[12,"bbb",E,E,8,N],[13,"Comp",R[112],"Compare register S with register `AAA`, see section above",8,N],[12,"aaa",R[113],E,8,N],[13,"Stck",R[112],"Stack manipulation, see member doc",8,N],[12,"d",R[113],E,8,N],[12,"r",E,E,8,N],[13,"Clrf",R[112],"Clear the 'F' register, by setting it to `0000 0000`",8,N],[13,"Halt",E,"Stop the CPU from doing any more execution",8,N],[11,"is_valid",E,"Check if this instruction doesn't use reserved space",8,[[["self"]],["bool"]]],[11,"display",E,"Get proxy object implementing `Display` for printing…",8,[[["self"]],[R[122]]]],[11,"is_valid",E,"Check if this operation doesn't use reserved space",7,[[["self"]],["bool"]]],[0,"util",R[114],"Module containing various utility functions.",N,N],[5,"limit_to_width","pir_8_emu::util","Limit the specified number to be at most the specified…",N,[[["num"],["primint"],["u8"]],[[R[3]],["num"],["primint"]]]],[11,"from",R[114],E,0,[[[T]],[T]]],[11,"into",E,E,0,[[],[U]]],[11,R[118],E,E,0,[[["self"]],[T]]],[11,R[117],E,E,0,[[[T],["self"]]]],[11,R[83],E,E,0,[[[U]],[R[85]]]],[11,R[84],E,E,0,[[],[R[85]]]],[11,R[86],E,E,0,[[["self"]],[T]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,R[119],E,E,0,[[["self"]],["typeid"]]],[11,R[115],R[116],E,1,[[["self"]],["string"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[],[U]]],[11,R[118],E,E,1,[[["self"]],[T]]],[11,R[117],E,E,1,[[[T],["self"]]]],[11,R[83],E,E,1,[[[U]],[R[85]]]],[11,R[84],E,E,1,[[],[R[85]]]],[11,R[86],E,E,1,[[["self"]],[T]]],[11,"borrow",E,E,1,[[["self"]],[T]]],[11,R[119],E,E,1,[[["self"]],["typeid"]]],[11,R[115],E,E,2,[[["self"]],["string"]]],[11,"from",E,E,2,[[[T]],[T]]],[11,"into",E,E,2,[[],[U]]],[11,R[118],E,E,2,[[["self"]],[T]]],[11,R[117],E,E,2,[[[T],["self"]]]],[11,R[83],E,E,2,[[[U]],[R[85]]]],[11,R[84],E,E,2,[[],[R[85]]]],[11,R[86],E,E,2,[[["self"]],[T]]],[11,"borrow",E,E,2,[[["self"]],[T]]],[11,R[119],E,E,2,[[["self"]],["typeid"]]],[11,R[115],R[112],E,9,[[["self"]],["string"]]],[11,"from",E,E,9,[[[T]],[T]]],[11,"into",E,E,9,[[],[U]]],[11,R[118],E,E,9,[[["self"]],[T]]],[11,R[117],E,E,9,[[[T],["self"]]]],[11,R[83],E,E,9,[[[U]],[R[85]]]],[11,R[84],E,E,9,[[],[R[85]]]],[11,R[86],E,E,9,[[["self"]],[T]]],[11,"borrow",E,E,9,[[["self"]],[T]]],[11,R[119],E,E,9,[[["self"]],["typeid"]]],[11,R[115],E,E,3,[[["self"]],["string"]]],[11,"from",E,E,3,[[[T]],[T]]],[11,"into",E,E,3,[[],[U]]],[11,R[118],E,E,3,[[["self"]],[T]]],[11,R[117],E,E,3,[[[T],["self"]]]],[11,R[83],E,E,3,[[[U]],[R[85]]]],[11,R[84],E,E,3,[[],[R[85]]]],[11,R[86],E,E,3,[[["self"]],[T]]],[11,"borrow",E,E,3,[[["self"]],[T]]],[11,R[119],E,E,3,[[["self"]],["typeid"]]],[11,R[115],E,E,4,[[["self"]],["string"]]],[11,"from",E,E,4,[[[T]],[T]]],[11,"into",E,E,4,[[],[U]]],[11,R[118],E,E,4,[[["self"]],[T]]],[11,R[117],E,E,4,[[[T],["self"]]]],[11,R[83],E,E,4,[[[U]],[R[85]]]],[11,R[84],E,E,4,[[],[R[85]]]],[11,R[86],E,E,4,[[["self"]],[T]]],[11,"borrow",E,E,4,[[["self"]],[T]]],[11,R[119],E,E,4,[[["self"]],["typeid"]]],[11,R[115],E,E,5,[[["self"]],["string"]]],[11,"from",E,E,5,[[[T]],[T]]],[11,"into",E,E,5,[[],[U]]],[11,R[118],E,E,5,[[["self"]],[T]]],[11,R[117],E,E,5,[[[T],["self"]]]],[11,R[83],E,E,5,[[[U]],[R[85]]]],[11,R[84],E,E,5,[[],[R[85]]]],[11,R[86],E,E,5,[[["self"]],[T]]],[11,"borrow",E,E,5,[[["self"]],[T]]],[11,R[119],E,E,5,[[["self"]],["typeid"]]],[11,R[115],E,E,6,[[["self"]],["string"]]],[11,"from",E,E,6,[[[T]],[T]]],[11,"into",E,E,6,[[],[U]]],[11,R[118],E,E,6,[[["self"]],[T]]],[11,R[117],E,E,6,[[[T],["self"]]]],[11,R[83],E,E,6,[[[U]],[R[85]]]],[11,R[84],E,E,6,[[],[R[85]]]],[11,R[86],E,E,6,[[["self"]],[T]]],[11,"borrow",E,E,6,[[["self"]],[T]]],[11,R[119],E,E,6,[[["self"]],["typeid"]]],[11,R[115],E,E,7,[[["self"]],["string"]]],[11,"from",E,E,7,[[[T]],[T]]],[11,"into",E,E,7,[[],[U]]],[11,R[118],E,E,7,[[["self"]],[T]]],[11,R[117],E,E,7,[[[T],["self"]]]],[11,R[83],E,E,7,[[[U]],[R[85]]]],[11,R[84],E,E,7,[[],[R[85]]]],[11,R[86],E,E,7,[[["self"]],[T]]],[11,"borrow",E,E,7,[[["self"]],[T]]],[11,R[119],E,E,7,[[["self"]],["typeid"]]],[11,"from",E,E,8,[[[T]],[T]]],[11,"into",E,E,8,[[],[U]]],[11,R[118],E,E,8,[[["self"]],[T]]],[11,R[117],E,E,8,[[[T],["self"]]]],[11,R[83],E,E,8,[[[U]],[R[85]]]],[11,R[84],E,E,8,[[],[R[85]]]],[11,R[86],E,E,8,[[["self"]],[T]]],[11,"borrow",E,E,8,[[["self"]],[T]]],[11,R[119],E,E,8,[[["self"]],["typeid"]]],[11,"clone",R[114],E,0,[[["self"]],["cpu"]]],[11,"clone",R[116],E,1,[[["self"]],[R[110]]]],[11,"clone",E,E,2,[[["self"]],[R[120]]]],[11,"clone",R[112],E,8,[[["self"]],[R[121]]]],[11,"clone",E,E,6,[[["self"]],[R[124]]]],[11,"clone",E,E,5,[[["self"]],[R[125]]]],[11,"clone",E,E,7,[[["self"]],[R[126]]]],[11,"clone",E,E,3,[[["self"]],[R[127]]]],[11,"clone",E,E,4,[[["self"]],[R[128]]]],[11,"clone",E,E,9,[[["self"]],[R[122]]]],[11,"cmp",R[114],E,0,[[["self"],["cpu"]],[R[123]]]],[11,"cmp",R[116],E,1,[[[R[110]],["self"]],[R[123]]]],[11,"cmp",E,E,2,[[[R[120]],["self"]],[R[123]]]],[11,"cmp",R[112],E,8,[[["self"],[R[121]]],[R[123]]]],[11,"cmp",E,E,6,[[["self"],[R[124]]],[R[123]]]],[11,"cmp",E,E,5,[[["self"],[R[125]]],[R[123]]]],[11,"cmp",E,E,7,[[["self"],[R[126]]],[R[123]]]],[11,"cmp",E,E,3,[[[R[127]],["self"]],[R[123]]]],[11,"cmp",E,E,4,[[["self"],[R[128]]],[R[123]]]],[11,"cmp",E,E,9,[[["self"],[R[122]]],[R[123]]]],[11,"from",E,E,8,[[["u8"]],[R[121]]]],[11,"from",E,E,6,[[["bool"]],[R[124]]]],[11,"from",E,E,5,[[["bool"]],[R[125]]]],[11,"from",E,E,3,[[["bool"]],[R[127]]]],[11,"into",E,E,8,[[],["u8"]]],[11,"into",E,E,7,[[],["u8"]]],[11,"into",E,E,4,[[],["u8"]]],[11,R[129],R[114],E,0,[[["self"],["cpu"]],[[R[3],[R[123]]],[R[123]]]]],[11,"lt",E,E,0,[[["self"],["cpu"]],["bool"]]],[11,"le",E,E,0,[[["self"],["cpu"]],["bool"]]],[11,"gt",E,E,0,[[["self"],["cpu"]],["bool"]]],[11,"ge",E,E,0,[[["self"],["cpu"]],["bool"]]],[11,R[129],R[116],E,1,[[[R[110]],["self"]],[[R[3],[R[123]]],[R[123]]]]],[11,"lt",E,E,1,[[[R[110]],["self"]],["bool"]]],[11,"le",E,E,1,[[[R[110]],["self"]],["bool"]]],[11,"gt",E,E,1,[[[R[110]],["self"]],["bool"]]],[11,"ge",E,E,1,[[[R[110]],["self"]],["bool"]]],[11,R[129],E,E,2,[[[R[120]],["self"]],[[R[3],[R[123]]],[R[123]]]]],[11,"lt",E,E,2,[[[R[120]],["self"]],["bool"]]],[11,"le",E,E,2,[[[R[120]],["self"]],["bool"]]],[11,"gt",E,E,2,[[[R[120]],["self"]],["bool"]]],[11,"ge",E,E,2,[[[R[120]],["self"]],["bool"]]],[11,R[129],R[112],E,8,[[["self"],[R[121]]],[[R[3],[R[123]]],[R[123]]]]],[11,"lt",E,E,8,[[["self"],[R[121]]],["bool"]]],[11,"le",E,E,8,[[["self"],[R[121]]],["bool"]]],[11,"gt",E,E,8,[[["self"],[R[121]]],["bool"]]],[11,"ge",E,E,8,[[["self"],[R[121]]],["bool"]]],[11,R[129],E,E,6,[[["self"],[R[124]]],[[R[3],[R[123]]],[R[123]]]]],[11,R[129],E,E,5,[[["self"],[R[125]]],[[R[3],[R[123]]],[R[123]]]]],[11,R[129],E,E,7,[[["self"],[R[126]]],[[R[3],[R[123]]],[R[123]]]]],[11,"lt",E,E,7,[[["self"],[R[126]]],["bool"]]],[11,"le",E,E,7,[[["self"],[R[126]]],["bool"]]],[11,"gt",E,E,7,[[["self"],[R[126]]],["bool"]]],[11,"ge",E,E,7,[[["self"],[R[126]]],["bool"]]],[11,R[129],E,E,3,[[[R[127]],["self"]],[[R[3],[R[123]]],[R[123]]]]],[11,R[129],E,E,4,[[["self"],[R[128]]],[[R[3],[R[123]]],[R[123]]]]],[11,R[129],E,E,9,[[["self"],[R[122]]],[[R[3],[R[123]]],[R[123]]]]],[11,"lt",E,E,9,[[["self"],[R[122]]],["bool"]]],[11,"le",E,E,9,[[["self"],[R[122]]],["bool"]]],[11,"gt",E,E,9,[[["self"],[R[122]]],["bool"]]],[11,"ge",E,E,9,[[["self"],[R[122]]],["bool"]]],[11,"eq",R[114],E,0,[[["self"],["cpu"]],["bool"]]],[11,"ne",E,E,0,[[["self"],["cpu"]],["bool"]]],[11,"eq",R[116],E,1,[[[R[110]],["self"]],["bool"]]],[11,"ne",E,E,1,[[[R[110]],["self"]],["bool"]]],[11,"eq",E,E,2,[[[R[120]],["self"]],["bool"]]],[11,"ne",E,E,2,[[[R[120]],["self"]],["bool"]]],[11,"eq",R[112],E,8,[[["self"],[R[121]]],["bool"]]],[11,"ne",E,E,8,[[["self"],[R[121]]],["bool"]]],[11,"eq",E,E,6,[[["self"],[R[124]]],["bool"]]],[11,"eq",E,E,5,[[["self"],[R[125]]],["bool"]]],[11,"eq",E,E,7,[[["self"],[R[126]]],["bool"]]],[11,"ne",E,E,7,[[["self"],[R[126]]],["bool"]]],[11,"eq",E,E,3,[[[R[127]],["self"]],["bool"]]],[11,"eq",E,E,4,[[["self"],[R[128]]],["bool"]]],[11,"eq",E,E,9,[[["self"],[R[122]]],["bool"]]],[11,"ne",E,E,9,[[["self"],[R[122]]],["bool"]]],[11,R[130],R[116],E,1,[[["self"]]]],[11,R[130],E,E,2,[[["self"]]]],[11,"fmt",E,E,1,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,2,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",R[112],E,8,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,6,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,5,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,7,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,3,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,4,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,9,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",R[116],E,1,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,2,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",R[112],E,9,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,6,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,5,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,7,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,3,[[["self"],[R[87]]],[R[85]]]],[11,"fmt",E,E,4,[[["self"],[R[87]]],[R[85]]]],[11,R[83],E,E,7,[[["u8"]],[[R[85],[R[126]]],[R[126]]]]],[11,R[83],E,E,4,[[["u8"]],[[R[85],[R[128]]],[R[128]]]]],[11,"deref",R[116],E,1,[[["self"]]]],[11,"deref",E,E,2,[[["self"]]]],[11,"hash",R[114],E,0,[[["self"],["__h"]]]],[11,"hash",R[116],E,1,[[["self"],["__h"]]]],[11,"hash",E,E,2,[[["self"],["__ht"]]]],[11,"hash",R[112],E,8,[[["self"],["__h"]]]],[11,"hash",E,E,6,[[["self"],["__h"]]]],[11,"hash",E,E,5,[[["self"],["__h"]]]],[11,"hash",E,E,7,[[["self"],["__h"]]]],[11,"hash",E,E,3,[[["self"],["__h"]]]],[11,"hash",E,E,4,[[["self"],["__h"]]]],[11,"hash",E,E,9,[[["self"],["__h"]]]]],"p":[[3,"Cpu"],[3,R[131]],[3,R[132]],[4,R[133]],[4,R[134]],[4,R[135]],[4,R[136]],[4,R[137]],[4,R[138]],[3,R[139]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);